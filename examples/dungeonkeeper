#!/usr/bin/env perl

use 5.014;
use experimental 'smartmatch';
use Daemonise;
use Getopt::Long;
use File::Find::Rule;
use File::Basename;
use JSON;

# PODNAME: dungeonkeeper

my $debug;
my $conf = '/etc/daemonise/dungeonkeeper.conf';
my $foreground;
my $queue = basename($0);
my $pid   = '/var/run/' . $queue . '.pid';

GetOptions(
    "debug|d"      => \$debug,
    "config|c=s"   => \$conf,
    "foreground|f" => \$foreground,
) or die;

my $command = pop(@ARGV);
die "$0 (start|stop|restart|status) [daemon1 daemon2 ...]" unless $command;

my $d = Daemonise->new();
$d->name($queue . '.' . $d->hostname);
$d->debug(1)      if $debug;
$d->debug(1)      if ($d->hostname =~ m/devel/);
$d->foreground(1) if $foreground;
$d->pid_file($pid);
$d->config_file($conf);
$d->configure;
$d->load_plugin('RabbitMQ');
$d->admin_queue(0);

given ($command) {
    when ("start") {
        $d->is_worker(1);
        check_config($d->config, 1);
        $d->start(\&main);
    }
    when ("stop")    { stop(@ARGV); }
    when ("restart") { restart(@ARGV); }
    when ("status")  { status(@ARGV); }
    default          { die "unknown command: $command"; }
}

sub main {
    my $base    = $d->config->{main}->{binbase};
    my $pidbase = $d->config->{main}->{pidbase};

    my $frame;
    eval {
        # also bind to "$queue"
        $d->mq->queue_bind($d->rabbit_channel, $d->name, 'amq.fanout', $queue);
        
        $frame = $d->mq->get($d->rabbit_channel, $d->name, { no_ack => 0 });
        $frame = $d->mq->get($d->rabbit_channel, $queue,   { no_ack => 0 })
            unless $frame;
    };

    if ($frame) {
        $d->log('received message: ' . $d->dump($frame)) if $d->debug;

        $d->mq->ack($d->rabbit_channel, $frame->{delivery_tag});

        my $msg =
            JSON->new->utf8->allow_blessed->convert_blessed->allow_nonref
            ->decode($frame->{body} || '{}');

        if ($frame->{routing_key} =~ m/^$queue/) {
            given ($msg->{command}) {
                when ('configure') {
                    if (exists $msg->{config}
                        and check_config($msg->{config}))
                    {
                        $d->log("updating in-memory config");

                        # find daemons that need to be stopped
                        # either daemon name disappeared or daemon count is <= 0
                        my @daemons;
                        for (keys %{ $d->config->{daemons} }) {
                            if (exists $msg->{config}->{daemons}->{$_}) {
                                push(@daemons, $_)
                                    if $msg->{config}->{daemons}->{$_} <= 0;
                            }
                            else {
                                push(@daemons, $_);
                            }
                        }

                        # stop all non-existing daemons if needed
                        restart(@daemons) if @daemons;

                        # store new config and keep going
                        $d->config($msg->{config});
                    }

                    $d->log("reconfiguring");
                    $d->configure('reconfig');
                }
                when ('deploy') {
                    $d->log("deploying");
                    $d->log(qx{git pull});
                    restart();
                    $d->configure('reconfig');
                }
                when ('stop') {
                    restart();
                    $d->stop;
                }
            }
        }
    }

    my $amount = rabbits();

    foreach my $rabbit (keys %{ $d->config->{daemons} }) {
        my $num = $amount->{$rabbit} || 0;
        if ($num < $d->config->{daemons}->{$rabbit}) {
            $d->log(  "daemon $rabbit needed ($num:"
                    . $d->config->{daemons}->{$rabbit}
                    . ")");
            $num++;
            my $pid_file =
                $pidbase . '/' . $rabbit . '.rabbit.' . $num . '.pid';

            # find a non existent pidfile
            while (-f $pid_file) {
                $num++;
                $pid_file =
                    $pidbase . '/' . $rabbit . '.rabbit.' . $num . '.pid';
            }

            # fork the new rabbit
            system("cd $base && bin/$rabbit.rabbit -p $pid_file");
        }
    }

    sleep($d->config->{main}->{sleep} || 1);
}

sub rabbits {
    my $pidbase = $d->config->{main}->{pidbase};
    my $amount  = {};
    my $files   = File::Find::Rule->new->file->name('*.pid')->start($pidbase);

    while (defined(my $pid_file = $files->match)) {

        # exract rabbit name from PID file
        $pid_file =~ m{$pidbase/(.*)\.rabbit\.\d+\.pid$};
        my $rabbit = $1;

        $amount->{$rabbit} = 0 unless (exists $amount->{$rabbit});

        # check if daemon is running and increase counter
        my $daemon = Daemonise->new();
        $daemon->pid_file($pid_file);
        my $status = $daemon->status;
        $amount->{$rabbit} += 1 if ($status);
    }

    return $amount;
}

sub stop {
    my (@daemons) = @_;

    $d->configure;

    if (@daemons) {
        $d->log('requesting to stop daemons: [' . join(' ', @daemons) . ']');

        for (@daemons) {
            delete $d->config->{daemons}->{$_}
                if exists $d->config->{daemons}->{$_};
        }

        $d->queue($d->name, { command => 'configure', config => $d->config });
        return;
    }

    $d->phase('status');
    $d->check_pid_file;
    restart();
    kill(15, $d->running) if $d->running;

    return;
}

sub restart {
    my (@daemons) = @_;

    if (@daemons) {
        $d->log('stopping daemons: [' . join(' ', @daemons) . ']');

        $d->queue(
            'admin.' . $d->hostname,
            { command => 'stop', daemons => \@daemons },
            undef, 'amq.fanout'
        );
        return;
    }

    $d->log("stopping all daemons");
    $d->queue(
        'admin.' . $d->hostname,
        { command => 'stop' },
        undef, 'amq.fanout'
    );

    return;
}

sub status {
    my $s = $d->status();
    if   ($s) { print $s . $/;         exit; }
    else      { print "not running\n"; exit 1; }
}

sub check_config {
    my ($config, $die) = @_;

    my $valid = 1;

    $valid = 0 unless ref $config eq 'HASH';
    $valid = 0 unless exists $config->{main};
    $valid = 0 unless ref $config->{main} eq 'HASH';
    $valid = 0
        unless exists $config->{main}->{user}
        and defined $config->{main}->{user};
    $valid = 0
        unless exists $config->{main}->{group}
        and defined $config->{main}->{group};
    $valid = 0
        unless exists $config->{main}->{binbase}
        and defined $config->{main}->{binbase};
    $valid = 0
        unless exists $config->{main}->{pidbase}
        and defined $config->{main}->{pidbase};
    $valid = 0
        unless ref $config->{daemons} eq 'HASH'
        and keys %{ $config->{daemons} };

    if ($valid and $die) {
        my $binbase = $config->{main}->{binbase};
        my $pidbase = $config->{main}->{pidbase};
        my $user    = $config->{main}->{user};
        my $group   = $config->{main}->{group};

        # create PID dir and ensure correct owner/group/permissions
        mkdir($pidbase, 0755) unless (-d $pidbase);
        my (undef, undef, $uid) = getpwnam($user);
        my (undef, undef, $gid) = getgrnam($group);
        chown($uid, $gid, $pidbase) if ($uid or $gid);

        die("not a directory: $binbase") unless (-d $binbase);
    }

    return 1 if $valid;

    return unless $die;

    die('config misses mandatory entries');
}
